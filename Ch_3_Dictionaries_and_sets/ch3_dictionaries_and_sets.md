# Глава 3. Словари и множества

## Распаковка отображений

**Отображениe** — контейнер, элементы которого являются соответствиями одних данных другим. Первые при этом называют ключами, вторые — значениями. Отображения могут быть как изменяемыми, так и неизменяемыми. Примерами изменяемых отображений в стандартной библиотеке являются словарь и его наследники (например в модуле collections).

Оператор ** можно применять более чем к  одному аргументу вызванной функции. Это допустимо, когда все ключи являются строками и среди аргументов нет повторяющихся ключей (т. к. дубликаты именованных
аргументов запрещены).

```python
>>> def dump(**kwargs):
... return kwargs
...
>>> dump(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}
```

Во-вторых, оператор ** можно использовать внутри словарного литерала –
и тоже несколько раз. В этом случае повторяющиеся ключи разрешены. Последующее вхождение
ключа перезаписывает предыдущее (как в случае значения x в примере выше).

```python
>>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}
{'a': 0, 'x': 4, 'y': 2, 'z': 3}
```

## Объединение отображений оператором |

Обычно тип нового отображения совпадает с  типом левого операнда, d1
в  примере выше, но может совпадать и  с типом правого, если в  операции
участвуют определенные пользователем типы.

```python
Оператор | создает новое отображение:
>>> d1 = {'a': 1, 'b': 3}
>>> d2 = {'a': 2, 'b': 4, 'c': 6}
>>> d1 | d2
{'a': 2, 'b': 4, 'c': 6}
```

Для модификации уже имеющегося отображения на месте служит оператор
|=.
```python
>>> d1
{'a': 1, 'b': 3}
>>> d1 |= d2
>>> d1
{'a': 2, 'b': 4, 'c': 6}
```

```python
def get_creators(record: dict) -> list:
    match record:
        # Сопоставить с любым отображением, в котором 'type': 'book', 'api' : 2, а ключу 'authors'
        # соответствует последовательность. Вернуть элементы последовательности в виде нового списка.
        case {'type': 'book', 'api': 2, 'authors': [*names]}: 
            return names
        # Сопоставить с любым отображением, в котором 'type': 'book', 'api' : 1, а ключу 'author' 
        # соответствует произвольный объект. Вернуть этот объект в  виде элемента списка.
        case {'type': 'book', 'api': 1, 'author': name}:
            return [name]
        # Любое другое отображение, в  котором 'type': 'book', недопустимо, 
        # возбудить исключение ValueError.
        case {'type': 'book'}:
            raise ValueError(f"Invalid 'book' record: {record!r}")
        # Сопоставить с  любым отображением, в  котором 'type': 'movie', а  ключу
        # 'director' соответствует одиночный объект. Вернуть этот объект в виде элемента списка.
        case {'type': 'movie', 'director': name}:
            return [name]
        # Любой другой субъект недопустим, возбудить исключение ValueError.
        case _:
            raise ValueError(f'Invalid record: {record! r}')
```

Использовать аргумент **extra для сопоставления с лишними парами ключзначение необязательно,но если вы хотите собрать их в словарь,то можете указать одну переменную с префиксом **. Она должна быть последней в образце, а конструкция **_ запрещена ввиду своей избыточности. Вот простой пример:

```python
>>> food = dict(category='ice cream', flavor='vanilla', cost=199)
>>> match food:
... case {'category': 'ice cream', **details}:
... print(f'Ice cream details: {details}')
...
Ice cream details: {'flavor': 'vanilla', 'cost': 199}
```

## Что значит «хешируемый»?

Объект называется **хешируемым**, если имеет хеш-код, который не изменяется на протяжении всего времени его жизни (у него должен быть метод __hash__()), и допускает сравнение с другими объектами (у него должен быть метод __eq__()). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны.

```python
>>> tt = (1, 2, (30, 40))
>>> hash(tt)
8027212646858338501
>>> tl = (1, 2, [30, 40])
>>> hash(tl)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> tf = (1, 2, frozenset([30, 40]))
>>> hash(tf)
-4118419923444501110
```

## Вставка и обновление изменяемых значений: setdefault()

```python
"""Строит индекс, отображающий слово на список его вхождений"""
import re
import sys

WORD_RE = re.compile(r'\w+')
index = {}
with open(sys.argv[1], encoding='utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start() + 1
            location = (line_no, column_no)
            # Получить список вхождений слова word или установить его равным [], если
            # слово не найдено; setdefault возвращает значение, поэтому список можно
            # обновить без повторного поиска.
            index.setdefault(word, []).append(location)

# напечатать в алфавитном порядке
# При задании аргумента key функции sorted мы не вызываем str.upper,  
# а только передаем ссылку на этот метод, чтобы sorted могла 
# нормализовать слова перед сортировкой
for word in sorted(index, key=str.upper):
    print(word, index[word])
```

## defaultdict: еще один подход к обработке отсутствия ключа

использование экземпляра defaultdict вместо метода setdefault
```python
"""Строит индекс, отображающий слово на список его вхождений"""
import collections
import re
import sys

WORD_RE = re.compile(r'\w+')
# Создать defaultdict, задав в качестве default_factory конструктор list.
index = collections.defaultdict(list) 
with open(sys.argv[1], encoding='utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start() + 1
            location = (line_no, column_no)
            # Если слова word еще нет в index, то вызывается функция default_factory,
            # которая порождает отсутствующее значение – в данном случае пустой список.
            # Это значение присваивается index[word] и возвращается, так что операция
            # .append(location) всегда завершается успешно.
            index[word].append(location) 

# напечатать в алфавитном порядке
for word in sorted(index, key=str.upper):
    print(word, index[word])
```

Атрибут default_factory объекта defaultdict вызывается только
для того, чтобы предоставить значение по умолчанию при обращении 
к методу \_\_*getitem*__ и только к нему. Например, если dd – 
объект класса defaultdict и k – отсутствующий ключ, то при
вычислении выражения dd[k] происходит обращение к default_
factory для создания значения по умолчанию, а вызов dd.get(k)
все равно возвращает None и k in dd равно False.

## collections.OrderedDict

Использовать OrderedDict имеет смысл главным образом для поддержания обратной совместимости с предыдущими версиями.
- Оператор равенства в классе OrderedDict проверяет, что порядок следования ключей одинаков
- Метод popitem() в классе OrderedDict имеет другую сигнатуру. Он принимает необязательный аргумент, указывающий, какой элемент извлечь.
- В классе OrderedDict имеется метод move_to_end(), который эффективно переходит к последнему элементу в словаре.
- При проектировании обычного dict на первое место ставилась высокая
эффективность операций отображения, а отслеживание порядка вставки
было вторичным.
- При проектировании OrderedDict на первое место ставилась высокая эффективность операций переупорядочения, а  эффективность использования памяти, скорость итерирования и производительность операций
обновления были вторичны.
- Алгоритмически OrderedDict справляется с частыми операциями переупорядочения лучше, чем dict. Поэтому он подходит для отслеживания недавних операций доступа (например, в LRU-кеше).
  
## collections.ChainMap

Хранит список отображений, так что их можно просматривать как единое целое. Поиск производится в каждом отображении в порядке их перечисления в  конструкторе и  завершается успешно, если ключ найден хотя бы в  одном

```python
>>> d1 = dict(a=1, b=3)
>>> d2 = dict(a=2, b=4, c=6)
>>> from collections import ChainMap
>>> chain = ChainMap(d1, d2)
>>> chain['a']
1
>>> chain['c']
6
```

Экземпляр ChainMap не  копирует входные отображения, а  хранит ссылки на
них. Все модификации и  вставки ChainMap применяются только к  первому из
входных отображений.

```python
>>> chain['c'] = -1
>>> d1
{'a': 1, 'b': 3, 'c': -1}
>>> d2
{'a': 2, 'b': 4, 'c': 6}
```

## collections.Counter

Отображение, в котором с каждым ключом ассоциирован счетчик. Обновление
существующего ключа увеличивает его счетчик. Этот класс можно использовать
для подсчета количества хешируемых объектов или в качестве мультимножества
(обсуждается ниже в данном разделе). В классе Counter реализованы операторы +
и - для объединения серий и другие полезные методы, например most_common([n]),
который возвращает упорядоченный список кортежей, содержащий n  самых
часто встречающихся элементов вместе с их счетчиками.

```python
>>> ct = collections.Counter('abracadabra')
>>> ct
Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
>>> ct.update('aaaaazzz')
>>> ct
Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
>>> ct.most_common(3)
[('a', 10), ('z', 3), ('b', 2)]
```
Обратите внимание, что оба ключа 'b' и 'r' делят третье место, но ct.most_
common(3) показывает только три счетчика. Чтобы воспользоваться классом collections.Counter как мультимножеством, представьте, что каждый ключ – элемент множества, а счетчик – количество
вхождений этого элемента в множество.

## shelve.Shelf

Модуль shelve из стандартной библиотеки предоставляет постоянное хранилище для отображения строковых ключей на объекты Python, сериализованные в двоичном формате pickle. Название shelve (полка) – намек на то, что банки с соленьями (pickle) хранятся на полках

Функция уровня модуля shelve.open возвращает экземпляр shelve.Shelf – простую базу ключей и значений, поддерживаемую модулем dbm и обладающую следующими свойствами:
- shelve.Shelf является подклассом abc.MutableMapping, т. е. предоставляет основные методы, ожидаемые от типа отображения;
- кроме того, shelve.Shelf предоставляет еще несколько методов для управления вводом-выводом, например sync и close;
- экземпляр Shelf является контекстным менеджером, поэтому его можно
включать в блок with, гарантирующий закрытие после использования;
- ключи и значения сохраняются при каждом присваивании нового значения ключу. Ключи должны быть строками;
- значения должны быть объектами, которые модуль pickle умеет сериализовывать.
