# Глава 3. Словари и множества

## Распаковка отображений

**Отображениe** — контейнер, элементы которого являются соответствиями одних данных другим. Первые при этом называют ключами, вторые — значениями. Отображения могут быть как изменяемыми, так и неизменяемыми. Примерами изменяемых отображений в стандартной библиотеке являются словарь и его наследники (например в модуле collections).

Оператор ** можно применять более чем к  одному аргументу вызванной функции. Это допустимо, когда все ключи являются строками и среди аргументов нет повторяющихся ключей (т. к. дубликаты именованных
аргументов запрещены).

```python
>>> def dump(**kwargs):
... return kwargs
...
>>> dump(**{'x': 1}, y=2, **{'z': 3})
{'x': 1, 'y': 2, 'z': 3}
```

Во-вторых, оператор ** можно использовать внутри словарного литерала –
и тоже несколько раз. В этом случае повторяющиеся ключи разрешены. Последующее вхождение
ключа перезаписывает предыдущее (как в случае значения x в примере выше).

```python
>>> {'a': 0, **{'x': 1}, 'y': 2, **{'z': 3, 'x': 4}}
{'a': 0, 'x': 4, 'y': 2, 'z': 3}
```

## Объединение отображений оператором |

Обычно тип нового отображения совпадает с  типом левого операнда, d1
в  примере выше, но может совпадать и  с типом правого, если в  операции
участвуют определенные пользователем типы.

```python
Оператор | создает новое отображение:
>>> d1 = {'a': 1, 'b': 3}
>>> d2 = {'a': 2, 'b': 4, 'c': 6}
>>> d1 | d2
{'a': 2, 'b': 4, 'c': 6}
```

Для модификации уже имеющегося отображения на месте служит оператор
|=.
```python
>>> d1
{'a': 1, 'b': 3}
>>> d1 |= d2
>>> d1
{'a': 2, 'b': 4, 'c': 6}
```

```python
def get_creators(record: dict) -> list:
    match record:
        # Сопоставить с любым отображением, в котором 'type': 'book', 'api' : 2, а ключу 'authors'
        # соответствует последовательность. Вернуть элементы последовательности в виде нового списка.
        case {'type': 'book', 'api': 2, 'authors': [*names]}: 
            return names
        # Сопоставить с любым отображением, в котором 'type': 'book', 'api' : 1, а ключу 'author' 
        # соответствует произвольный объект. Вернуть этот объект в  виде элемента списка.
        case {'type': 'book', 'api': 1, 'author': name}:
            return [name]
        # Любое другое отображение, в  котором 'type': 'book', недопустимо, 
        # возбудить исключение ValueError.
        case {'type': 'book'}:
            raise ValueError(f"Invalid 'book' record: {record!r}")
        # Сопоставить с  любым отображением, в  котором 'type': 'movie', а  ключу
        # 'director' соответствует одиночный объект. Вернуть этот объект в виде элемента списка.
        case {'type': 'movie', 'director': name}:
            return [name]
        # Любой другой субъект недопустим, возбудить исключение ValueError.
        case _:
            raise ValueError(f'Invalid record: {record! r}')
```

Использовать аргумент **extra для сопоставления с лишними парами ключзначение необязательно,но если вы хотите собрать их в словарь,то можете указать одну переменную с префиксом **. Она должна быть последней в образце, а конструкция **_ запрещена ввиду своей избыточности. Вот простой пример:

```python
>>> food = dict(category='ice cream', flavor='vanilla', cost=199)
>>> match food:
... case {'category': 'ice cream', **details}:
... print(f'Ice cream details: {details}')
...
Ice cream details: {'flavor': 'vanilla', 'cost': 199}
```

## Что значит «хешируемый»?

Объект называется **хешируемым**, если имеет хеш-код, который не изменяется на протяжении всего времени его жизни (у него должен быть метод __hash__()), и допускает сравнение с другими объектами (у него должен быть метод __eq__()). Если в результате сравнения хешируемых объектов оказывается, что они равны, то и их хеш-коды должны быть равны.

```python
>>> tt = (1, 2, (30, 40))
>>> hash(tt)
8027212646858338501
>>> tl = (1, 2, [30, 40])
>>> hash(tl)
Traceback (most recent call last):
 File "<stdin>", line 1, in <module>
TypeError: unhashable type: 'list'
>>> tf = (1, 2, frozenset([30, 40]))
>>> hash(tf)
-4118419923444501110
```

## Вставка и обновление изменяемых значений: setdefault()

```python
"""Строит индекс, отображающий слово на список его вхождений"""
import re
import sys

WORD_RE = re.compile(r'\w+')
index = {}
with open(sys.argv[1], encoding='utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start() + 1
            location = (line_no, column_no)
            # Получить список вхождений слова word или установить его равным [], если
            # слово не найдено; setdefault возвращает значение, поэтому список можно
            # обновить без повторного поиска.
            index.setdefault(word, []).append(location)

# напечатать в алфавитном порядке
# При задании аргумента key функции sorted мы не вызываем str.upper,  
# а только передаем ссылку на этот метод, чтобы sorted могла 
# нормализовать слова перед сортировкой
for word in sorted(index, key=str.upper):
    print(word, index[word])
```

## defaultdict: еще один подход к обработке отсутствия ключа

использование экземпляра defaultdict вместо метода setdefault
```python
"""Строит индекс, отображающий слово на список его вхождений"""
import collections
import re
import sys

WORD_RE = re.compile(r'\w+')
# Создать defaultdict, задав в качестве default_factory конструктор list.
index = collections.defaultdict(list) 
with open(sys.argv[1], encoding='utf-8') as fp:
    for line_no, line in enumerate(fp, 1):
        for match in WORD_RE.finditer(line):
            word = match.group()
            column_no = match.start() + 1
            location = (line_no, column_no)
            # Если слова word еще нет в index, то вызывается функция default_factory,
            # которая порождает отсутствующее значение – в данном случае пустой список.
            # Это значение присваивается index[word] и возвращается, так что операция
            # .append(location) всегда завершается успешно.
            index[word].append(location) 

# напечатать в алфавитном порядке
for word in sorted(index, key=str.upper):
    print(word, index[word])
```

Атрибут default_factory объекта defaultdict вызывается только
для того, чтобы предоставить значение по умолчанию при обращении 
к методу \_\_*getitem*__ и только к нему. Например, если dd – 
объект класса defaultdict и k – отсутствующий ключ, то при
вычислении выражения dd[k] происходит обращение к default_
factory для создания значения по умолчанию, а вызов dd.get(k)
все равно возвращает None и k in dd равно False.

